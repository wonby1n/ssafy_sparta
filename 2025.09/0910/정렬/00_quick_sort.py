# A : 정렬 대상 배열
# l, r : 정렬 범위 시작 인덱스, 종료 인덱스
def quicksort(A, l, r):
    if l < r:
        # 기준원소를 정해서 기준원소의 위치가 확정되고
        p = partition(A, l, r)

        # 기준원소의 왼쪽 부분 정렬
        quicksort(A, l, p-1)
        # 기준원소의 오른쪽 부분 정렬
        quicksort(A, p+1, r)


def partition(A, l, r):
    # A의 가장 왼쪽에 있는 원소가 기준
    p = A[l]

    # p보다 작은 원소를 왼쪽에
    # p보다 큰 원소를 오른쪽에

    # 앞에서부터 p보다 큰 원소를 찾고
    # 뒤에서부터 p보다 작은 원소를 찾으면
    # 이 두 원소는 위치가 잘못되어 있으니 서로 교환
    # 앞에서부터 찾기 위한 인덱스
    i = l
    # 뒤에서부터 찾기 위한 인덱스
    j = r

    # i랑 j가 교차하기 전까지
    while i <= j:
        # i위치는 왼쪽에서부터 +1씩 증가
        # i번 인덱스에 있는 원소가 p보다 작으면
        # 자기자리가 맞음, +1 해가며 다음원소 탐색
        while i <= j and A[i] <= p:
            i += 1

        # j위치는 오른쪽에서부터 -1씩 감소
        # j번 인덱스에 있는 원소가 p보다 크면
        # 자기 자리가 맞음, -1 해가면서 다음원소 탐색
        while i <= j and A[j] <= p:
            j -= 1

        # 두개의 반복문이 끝나고 나서
        # 여전히 i가 j보다 작으면
        # p보다 큰 원소가 i번에 있다
        # p보다 작은 원소가 j번에 있다
        # 그럼 바꿔주면 된다
        if i < j:
            A[i], A[j] = A[i], A[j]

    # i랑 j가 교차
    # 왼쪽에는 기준보다 작은 원소들이 모여있고
    # 오른쪽에는 기준보다 큰 원소들이 모여있음
    # 기준 원소를 그 사이에 끼워넣으면 위치 확정
    A[l], A[j] = A[j], A[l]
    # i와 j가 교차했으므로 j가 i보다 작은 상황
    # 기준원소(피벗)을 그중에 작은것과 바꿔야
    # 작은 원소들이 왼쪽, 큰원소들이 오른쪽이라는 규칙을
    # 지킬 수 있게 된다

    # 기준원소의 위치는 어디로 확정?? => j
    return j

li = [11, 45, 23, 81, 28, 34]

N = len(li)
quicksort(li, 0, N-1)
print(li)