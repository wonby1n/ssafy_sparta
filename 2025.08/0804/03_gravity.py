# 가로 칸의 수는 N
N = int(input())
# 각 칸의 상자 높이
lst = list(map(int, input().split()))

# 0번째 상자 탑에서 최대 낙차는?
# 1번째 상자 탑에서 최대 낙차는?
# ...
# n-1번째 상자 탑에서 최대 낙차는?

# 상자 탑들 중에서 낙차가 가장 큰 상자의 낙차는 얼마일까?
# 상자탑에서 맨 위를 제외한 나머지 상자는 고려할 필요 x
# 뒤집은 결과를 생각해보면 맨 위쪽 상자 낙차가 제일 높을것이기 때문

# 우리가 구하고자 하는 값 -> 낙차중에 최대값
max_drop = 0

# 모든 상자 탑의 낙차를 구하기 위해 반복문 사용
for i in range(N):
    # i번째 상자탑(i는 상자탑의 인덱스)에서 최대 낙차 구하기
    # i번 상자탑의 높이 h
    h = lst[i]

    # 낙차를 구하는 식
    # 가로 칸의 수(N) - i번 상자탑과 왼쪽 벽과의 거리
    # - i번 상자탑의 높이보다 크거나 같은, 오른쪽에 있는 상자탑의 개수(high_count)
    # i번 상자탑에서의 최대 낙차 = N - (i+1) - high_count

    # high_count 구하기
    high_count = 0
    # i번 상자탑의 오른쪽에 있는 상자탑의 높이를 전부 확인
    # 반복의 시작점과 종료점
    # i번 상자탑의 오른쪽 => (i+1)
    # 끝 => N
    # i번 오른쪽에 있는 상자탑의 번호를 j라고 하자.
    for j in range(i+1, N):
        # 이 j번 상자탑의 높이가 i번 상자탑보다 높은가?
        if lst[j] >= h:
            # 그렇다면 개수 + 1
            high_count += 1

    # i번 상자탑에서의
    # 최대 낙차 구하기
    drop = N - (i + 1) - high_count

    # 최대 낙차 비교
    if max_drop < drop:
        max_drop = drop

# 반복이 다 끝나면 최대 낙차가 구해져 있다.
print(max_drop)